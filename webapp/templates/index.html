<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Content Assistant</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
      background: #0f1117;
      color: #e4e4e7;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .chat-header {
      background: #18181b;
      border-bottom: 1px solid #27272a;
      padding: 1rem 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-shrink: 0;
    }

    .rocket-icon {
      width: 28px;
      height: 28px;
      color: #a78bfa;
    }

    .chat-header h1 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #fafafa;
    }

    /* Messages Area */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 2rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .messages-container::-webkit-scrollbar {
      width: 8px;
    }

    .messages-container::-webkit-scrollbar-track {
      background: #18181b;
    }

    .messages-container::-webkit-scrollbar-thumb {
      background: #3f3f46;
      border-radius: 4px;
    }

    .message {
      display: flex;
      gap: 0.75rem;
      max-width: 800px;
      animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      margin-left: auto;
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .message.user .message-avatar {
      background: #7c3aed;
      color: white;
    }

    .message.assistant .message-avatar {
      background: #27272a;
      color: #a78bfa;
    }

    .message-content {
      background: #18181b;
      padding: 1rem;
      border-radius: 1rem;
      border: 1px solid #27272a;
      line-height: 1.6;
    }

    .message.user .message-content {
      background: #7c3aed;
      border-color: #7c3aed;
      color: white;
    }

    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      color: #71717a;
      text-align: center;
      padding: 2rem;
    }

    .empty-state-icon {
      width: 64px;
      height: 64px;
      opacity: 0.5;
    }

    /* Input Area */
    .input-container {
      border-top: 1px solid #27272a;
      background: #18181b;
      padding: 1.5rem;
      flex-shrink: 0;
    }

    .input-wrapper {
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .textarea-wrapper {
      flex: 1;
      position: relative;
    }

    textarea {
      width: 100%;
      min-height: 56px;
      max-height: 200px;
      padding: 1rem;
      border: 1px solid #3f3f46;
      border-radius: 0.75rem;
      background: #0f1117;
      color: #e4e4e7;
      font-size: 1rem;
      font-family: inherit;
      resize: none;
      outline: none;
      transition: border-color 0.2s;
    }

    textarea:focus {
      border-color: #7c3aed;
    }

    textarea::placeholder {
      color: #52525b;
    }

    .send-button {
      height: 56px;
      width: 56px;
      background: #7c3aed;
      border: none;
      border-radius: 0.75rem;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
      flex-shrink: 0;
    }

    .send-button:hover {
      background: #6d28d9;
    }

    .send-button:active {
      transform: scale(0.95);
    }

    .send-button:disabled {
      background: #3f3f46;
      cursor: not-allowed;
      opacity: 0.5;
    }

    .send-icon {
      width: 20px;
      height: 20px;
    }

    .status-line {
    font-style: italic;
    color: #a1a1aa; /* A lighter gray color */
    font-size: 0.875rem;
    margin-bottom: 0.5rem;
    animation: fadeIn 0.5s ease-in;
    }

    @media (max-width: 640px) {
      .chat-header {
        padding: 1rem;
      }

      .messages-container {
        padding: 1rem;
      }

      .input-container {
        padding: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="chat-container">
    <!-- Header -->
    <header class="chat-header">
      <svg class="rocket-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
      </svg>
      <h1>AI Content Assistant</h1>
    </header>

    <!-- Messages Container -->
    <div class="messages-container" id="messagesContainer">
      <div class="empty-state">
        <svg class="empty-state-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
        </svg>
        <p>Start a conversation with your AI Content Assistant</p>
      </div>
    </div>

    <!-- Input Area -->
    <div class="input-container">
      <div class="input-wrapper">
        <div class="textarea-wrapper">
          <textarea 
            id="messageInput" 
            placeholder="Type your message here..."
            rows="1"
          ></textarea>
        </div>
        <button class="send-button" id="sendButton">
          <svg class="send-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
          </svg>
        </button>
      </div>
    </div>
  </div>

  <script>
    // 1. 获取新界面中的所有关键元素
    const messagesContainer = document.getElementById('messagesContainer');
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');

    // 2. 自动调整输入框高度 (这个功能来自v0模板，非常实用，我们保留)
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      // 限制最大高度为200px
      this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });

    // 3. 【核心】发送消息到后端，并以流式方式处理响应
    async function sendMessage() {
      const userMessage = messageInput.value.trim();
      if (!userMessage) return;

      // 如果聊天窗口里有初始的“空状态”提示，就把它移除
      const emptyState = messagesContainer.querySelector('.empty-state');
      if (emptyState) {
        emptyState.remove();
      }

      // 在界面上立刻显示用户自己发送的消息
      addMessage(userMessage, 'user');

      // 清空输入框，并恢复其原始高度
      messageInput.value = '';
      messageInput.style.height = 'auto';
      
      // 立刻创建一个AI消息的“占位符”，我们将逐步填充它
      const aiMessageElement = addMessage('', 'assistant');
      const aiContentElement = aiMessageElement.querySelector('.message-content');
      // 初始状态
      aiContentElement.innerHTML = '<div class="status-line">AI 正在准备...</div>';

      try {
        // 调用我们的 /chat API，它现在会返回一个数据流
        const response = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: userMessage }),
        });

        if (!response.ok) {
          throw new Error(`服务器错误: ${response.status}`);
        }

        // 使用 ReadableStream API 来处理数据流
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let isAnswerSection = false;
        let finalAnswer = '';

        // 循环读取数据流的每一个“块” (chunk)
        while (true) {
          const { value, done } = await reader.read();
          if (done) break; // 如果数据流结束，就跳出循环
          
          // 将二进制数据块解码为字符串
          const chunk = decoder.decode(value, { stream: true });
          // 按换行符分割，因为后端是用换行符来分隔每条状态的
          const lines = chunk.split('\n').filter(line => line.trim() !== '');

          for (const line of lines) {
            // 我们用 "答案：" 这个特殊标记来区分“状态更新”和“最终答案”
            if (line.trim() === '答案：') {
              isAnswerSection = true;
              // 清空之前所有的状态行，准备开始打印最终答案
              aiContentElement.innerHTML = ''; 
              continue; // 继续处理下一行
            }

            if (isAnswerSection) {
              // 如果是答案部分，就逐字追加内容，实现打字机效果
              finalAnswer += line;
              // 使用 textContent 来防止 HTML 注入，更安全
              aiContentElement.textContent = finalAnswer;
            } else {
              // 如果是状态更新部分，就创建并追加一个新的状态行
              const statusLine = document.createElement('div');
              statusLine.className = 'status-line';
              statusLine.textContent = line;
              aiContentElement.appendChild(statusLine);
            }
            // 每次更新内容后，都自动滚动到聊天窗口底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }
        }

      } catch (error) {
        console.error('调用API失败:', error);
        // 如果发生错误，就在AI消息框里显示错误信息
        const aiContentElement = aiMessageElement.querySelector('.message-content');
        aiContentElement.textContent = `出错了: ${error.message}`;
      }
    }

    // 4. 在聊天窗口中添加一条新消息的辅助函数
    function addMessage(text, type) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${type}`;

      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.textContent = type === 'user' ? 'U' : 'AI';

      const content = document.createElement('div');
      content.className = 'message-content';
      // 注意：这里我们直接用 textContent，更安全。如果需要支持HTML，可以用 innerHTML
      content.textContent = text;

      messageDiv.appendChild(avatar);
      messageDiv.appendChild(content);

      messagesContainer.appendChild(messageDiv);

      // 自动滚动到底部
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // 返回刚刚创建的消息元素，这对于后续更新内容至关重要
      return messageDiv;
    }

    // 5. 为发送按钮和输入框的回车键绑定发送消息的事件
    sendButton.addEventListener('click', sendMessage);

    messageInput.addEventListener('keydown', function(e) {
      // 当用户按下Enter键，并且没有同时按住Shift键时，发送消息
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // 阻止Enter键的默认行为（即在输入框中换行）
        sendMessage();
      }
    });
  </script>
</body>
</html>
